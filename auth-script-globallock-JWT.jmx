<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.4.1">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Test Plan" enabled="true">
      <stringProp name="TestPlan.comments"></stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.tearDown_on_shutdown">true</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments"/>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath"></stringProp>
    </TestPlan>
    <hashTree>
      <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="false">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <sentBytes>true</sentBytes>
            <url>true</url>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
            <connectTime>true</connectTime>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
        <collectionProp name="HeaderManager.headers">
          <elementProp name="" elementType="Header">
            <stringProp name="Header.name">Authorization</stringProp>
            <stringProp name="Header.value">Bearer ${token}</stringProp>
          </elementProp>
          <elementProp name="Accept" elementType="Header">
            <stringProp name="Header.name">Accept</stringProp>
            <stringProp name="Header.value">application/json</stringProp>
          </elementProp>
          <elementProp name="Content-Type" elementType="Header">
            <stringProp name="Header.name">Content-Type</stringProp>
            <stringProp name="Header.value">application/json+v1</stringProp>
          </elementProp>
          <elementProp name="AcomAuth" elementType="Header">
            <stringProp name="Header.name">AcomAuth</stringProp>
            <stringProp name="Header.value">${__P(globaltoken)}</stringProp>
          </elementProp>
        </collectionProp>
      </HeaderManager>
      <hashTree/>
      <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables 1" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="host" elementType="Argument">
            <stringProp name="Argument.name">host</stringProp>
            <stringProp name="Argument.value">${__P(hostName,dnasvc-ethnicity.companynamel2.int)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="p_authserver" elementType="Argument">
            <stringProp name="Argument.name">p_authserver</stringProp>
            <stringProp name="Argument.value">${__P(p_authserver,acom-auth.companynamel2.int)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="env" elementType="Argument">
            <stringProp name="Argument.name">env</stringProp>
            <stringProp name="Argument.value">${__P(env,l2)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </Arguments>
      <hashTree/>
      <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables: specific for authtoken" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="expiredvar" elementType="Argument">
            <stringProp name="Argument.name">expiredvar</stringProp>
            <stringProp name="Argument.value">${__property(expiredvar,expired,true)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="tokenexpirytime1" elementType="Argument">
            <stringProp name="Argument.name">tokenexpirytime1</stringProp>
            <stringProp name="Argument.value">${__setProperty(tokenexpirytime,600000)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">//tokenexpirytime</stringProp>
          </elementProp>
          <elementProp name="globaltoken1" elementType="Argument">
            <stringProp name="Argument.name">globaltoken1</stringProp>
            <stringProp name="Argument.value">${__setProperty(globaltoken,)}</stringProp>
            <stringProp name="Argument.desc">//set initial token as null</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="expired1" elementType="Argument">
            <stringProp name="Argument.name">expired1</stringProp>
            <stringProp name="Argument.value">${__setProperty(expired,true)}</stringProp>
            <stringProp name="Argument.desc">// expired value to check if token expired or not</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="" elementType="Argument">
            <stringProp name="Argument.name"></stringProp>
            <stringProp name="Argument.value">${__property(tokenexpirytime,,600000)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
        <stringProp name="TestPlan.comments">${__property(abcd,ABCD,atod)} </stringProp>
      </Arguments>
      <hashTree/>
      <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV: User Details" enabled="true">
        <stringProp name="delimiter">,</stringProp>
        <stringProp name="fileEncoding"></stringProp>
        <stringProp name="filename">${__P(sample_id,sample_ids.csv)}</stringProp>
        <boolProp name="ignoreFirstLine">false</boolProp>
        <boolProp name="quotedData">false</boolProp>
        <boolProp name="recycle">true</boolProp>
        <stringProp name="shareMode">shareMode.all</stringProp>
        <boolProp name="stopThread">false</boolProp>
        <stringProp name="variableNames">sample_id</stringProp>
      </CSVDataSet>
      <hashTree/>
      <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV : PriavteKey " enabled="true">
        <stringProp name="delimiter">,</stringProp>
        <stringProp name="fileEncoding"></stringProp>
        <stringProp name="filename">${__P(privateKey,privateKey.csv)}</stringProp>
        <boolProp name="ignoreFirstLine">false</boolProp>
        <boolProp name="quotedData">false</boolProp>
        <boolProp name="recycle">true</boolProp>
        <stringProp name="shareMode">shareMode.all</stringProp>
        <boolProp name="stopThread">false</boolProp>
        <stringProp name="variableNames">privateKey</stringProp>
      </CSVDataSet>
      <hashTree/>
      <ConfigTestElement guiclass="HttpDefaultsGui" testclass="ConfigTestElement" testname="HTTP Request Defaults" enabled="true">
        <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments"/>
        </elementProp>
        <stringProp name="HTTPSampler.domain"></stringProp>
        <stringProp name="HTTPSampler.port"></stringProp>
        <stringProp name="HTTPSampler.protocol">https</stringProp>
        <stringProp name="HTTPSampler.contentEncoding"></stringProp>
        <stringProp name="HTTPSampler.path"></stringProp>
        <stringProp name="HTTPSampler.concurrentPool">6</stringProp>
        <stringProp name="HTTPSampler.connect_timeout"></stringProp>
        <stringProp name="HTTPSampler.response_timeout"></stringProp>
      </ConfigTestElement>
      <hashTree/>
      <CookieManager guiclass="CookiePanel" testclass="CookieManager" testname="HTTP Cookie Manager" enabled="true">
        <collectionProp name="CookieManager.cookies"/>
        <boolProp name="CookieManager.clearEachIteration">false</boolProp>
        <boolProp name="CookieManager.controlledByThreadGroup">false</boolProp>
      </CookieManager>
      <hashTree/>
      <CacheManager guiclass="CacheManagerGui" testclass="CacheManager" testname="HTTP Cache Manager" enabled="true">
        <boolProp name="clearEachIteration">true</boolProp>
        <boolProp name="useExpires">false</boolProp>
        <boolProp name="CacheManager.controlledByThread">false</boolProp>
      </CacheManager>
      <hashTree/>
      <SetupThreadGroup guiclass="SetupThreadGroupGui" testclass="SetupThreadGroup" testname="setUp Thread Group" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
        <stringProp name="TestPlan.comments">this thread will initialize the properties that are shared for all threads and required to be access with props.get
// it is required since if we are launching 500 threads at the same second, we will see a spike of calls to authtoken or all threads getting queued at critical section controller</stringProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
      </SetupThreadGroup>
      <hashTree>
        <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Module GenerateAuthToken" enabled="true"/>
        <hashTree>
          <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller" enabled="true">
            <stringProp name="IfController.condition">${__jexl3(${__P(expired)}==&quot;true&quot;,)}</stringProp>
            <boolProp name="IfController.evaluateAll">false</boolProp>
            <boolProp name="IfController.useExpression">true</boolProp>
            <stringProp name="TestPlan.comments">//enter the section only if token is expired</stringProp>
          </IfController>
          <hashTree>
            <CriticalSectionController guiclass="CriticalSectionControllerGui" testclass="CriticalSectionController" testname="Critical Section Controller" enabled="true">
              <stringProp name="CriticalSectionController.lockName">global_lock</stringProp>
              <stringProp name="TestPlan.comments">// We do not want all threads to enter this section and generate token. So, we are using java monitor/lock to control access so that when expired
only one thread generates a token and shares it with all threads</stringProp>
            </CriticalSectionController>
            <hashTree>
              <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller" enabled="true">
                <stringProp name="IfController.condition">${__jexl3(${__P(expired)}==&quot;true&quot;,)}</stringProp>
                <boolProp name="IfController.evaluateAll">false</boolProp>
                <boolProp name="IfController.useExpression">true</boolProp>
                <stringProp name="TestPlan.comments">// check token expiry again so that queued threads do not call auth token repeatedly and can read the expiry again
and decide when the previous thread had already generated the token</stringProp>
              </IfController>
              <hashTree>
                <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller" enabled="true">
                  <stringProp name="IfController.condition">${__jexl3(&quot;l1&quot;.equals(vars.get(&quot;env&quot;)))}</stringProp>
                  <boolProp name="IfController.evaluateAll">false</boolProp>
                  <boolProp name="IfController.useExpression">true</boolProp>
                </IfController>
                <hashTree>
                  <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Generate Authtoken -  " enabled="true">
                    <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
                    <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                      <collectionProp name="Arguments.arguments">
                        <elementProp name="" elementType="HTTPArgument">
                          <boolProp name="HTTPArgument.always_encode">false</boolProp>
                          <stringProp name="Argument.value">{&#xd;
  &quot;service&quot;: &quot;dnaapps-communities&quot;,&#xd;
    &quot;timestamp&quot;: &quot;${timestamp}&quot;,&#xd;
  &quot;signature&quot;: &quot;${signature}&quot;&#xd;
}</stringProp>
                          <stringProp name="Argument.metadata">=</stringProp>
                        </elementProp>
                      </collectionProp>
                    </elementProp>
                    <stringProp name="HTTPSampler.domain">${p_authserver}</stringProp>
                    <stringProp name="HTTPSampler.port"></stringProp>
                    <stringProp name="HTTPSampler.protocol">https</stringProp>
                    <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                    <stringProp name="HTTPSampler.path">tokens/generate</stringProp>
                    <stringProp name="HTTPSampler.method">POST</stringProp>
                    <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                    <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                    <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                    <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                    <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                    <stringProp name="HTTPSampler.connect_timeout">1000</stringProp>
                    <stringProp name="HTTPSampler.response_timeout">1000</stringProp>
                  </HTTPSamplerProxy>
                  <hashTree>
                    <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
                      <collectionProp name="HeaderManager.headers">
                        <elementProp name="Accept" elementType="Header">
                          <stringProp name="Header.name">Accept</stringProp>
                          <stringProp name="Header.value">*/*</stringProp>
                        </elementProp>
                        <elementProp name="Content-type" elementType="Header">
                          <stringProp name="Header.name">Content-type</stringProp>
                          <stringProp name="Header.value">application/v1+json</stringProp>
                        </elementProp>
                      </collectionProp>
                    </HeaderManager>
                    <hashTree/>
                    <JSR223PreProcessor guiclass="TestBeanGUI" testclass="JSR223PreProcessor" testname="JSR223 PreProcessor" enabled="true">
                      <stringProp name="scriptLanguage">groovy</stringProp>
                      <stringProp name="parameters"></stringProp>
                      <stringProp name="filename"></stringProp>
                      <stringProp name="cacheKey">true</stringProp>
                      <stringProp name="script">import java.security.Key;
import java.security.KeyFactory;
import java.security.Signature;
import java.security.spec.PKCS8EncodedKeySpec;
import org.apache.commons.codec.binary.Base64;

// Generate timestamp
String timestamp = new Date().format(&quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss&apos;Z&apos;&quot;, TimeZone.getTimeZone(&apos;UTC&apos;))
//Below is the private key for sfmc-customactivity service. 
//Need to update the script read this encoded key from the csv file which will be uploaded in PCOM 
String encodedKey = vars.get(&quot;privateKey&quot;);

// log.info(encodedKey);
String decodedKey = new String(Base64.decodeBase64(encodedKey));

// log.info(decodedKey);
String strippedKey = decodedKey.replaceAll(&quot;-----.*-----&quot;, &quot;&quot;);

// log.info(strippedKey);
byte[] bytes = Base64.decodeBase64(strippedKey);
Key privateKey = KeyFactory.getInstance(&quot;EC&quot;).generatePrivate(new PKCS8EncodedKeySpec(bytes));

// Create signature
Signature sig = Signature.getInstance(&quot;SHA256withECDSA&quot;);
sig.initSign(privateKey);
sig.update(timestamp.getBytes());
String signature = new String(Base64.encodeBase64(sig.sign()));

// Put variables
vars.put(&quot;timestamp&quot;, timestamp);
vars.put(&quot;signature&quot;, signature);</stringProp>
                    </JSR223PreProcessor>
                    <hashTree/>
                    <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="BeanShell Assertion" enabled="true">
                      <stringProp name="BeanShellAssertion.query">import net.minidev.json.JSONArray;
import net.minidev.json.JSONObject;
import net.minidev.json.parser.JSONParser;
import net.minidev.json.parser.ParseException;

Failure=true;
try {

	JSONParser p = new JSONParser();
	JSONObject obj = (JSONObject) p.parse(prev.getResponseDataAsString());
	String sToken  =  obj.get(&quot;token&quot;);
	if (sToken != null) {
		Failure = false;

			props.put(&quot;globaltoken&quot;, sToken);
			props.put(&quot;tokengenerationtime&quot;, System.currentTimeMillis().toString());		
			props.put(&quot;expired&quot;, &quot;false&quot;);		
			log.info(&quot;sToken:&quot; + sToken);
		
	}
	else {
		FailureMessage = &quot;sToken is null&quot;;
	}
			
}
catch (Exception e) {
	log.info(&quot;Exception in token generation:&quot; + e);
	FailureMessage = &quot;exception in token generation parsing assertion&quot;;

}
</stringProp>
                      <stringProp name="BeanShellAssertion.filename"></stringProp>
                      <stringProp name="BeanShellAssertion.parameters"></stringProp>
                      <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                    </BeanShellAssertion>
                    <hashTree/>
                    <ResultAction guiclass="ResultActionGui" testclass="ResultAction" testname="Result Status Action Handler" enabled="true">
                      <intProp name="OnError.action">4</intProp>
                      <stringProp name="TestPlan.comments">// retry token generation in case of failures</stringProp>
                    </ResultAction>
                    <hashTree/>
                  </hashTree>
                </hashTree>
                <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Controller" enabled="true">
                  <stringProp name="IfController.condition">${__jexl3(&quot;l2&quot;.equals(vars.get(&quot;env&quot;)))}</stringProp>
                  <boolProp name="IfController.evaluateAll">false</boolProp>
                  <boolProp name="IfController.useExpression">true</boolProp>
                </IfController>
                <hashTree>
                  <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Testing- get Auth Token for l2" enabled="true">
                    <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
                    <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
                      <collectionProp name="Arguments.arguments">
                        <elementProp name="" elementType="HTTPArgument">
                          <boolProp name="HTTPArgument.always_encode">false</boolProp>
                          <stringProp name="Argument.value">{&#xd;
  &quot;service&quot;: &quot;dnaapps-communities&quot;&#xd;
}</stringProp>
                          <stringProp name="Argument.metadata">=</stringProp>
                        </elementProp>
                      </collectionProp>
                    </elementProp>
                    <stringProp name="HTTPSampler.domain">${p_authserver}</stringProp>
                    <stringProp name="HTTPSampler.port"></stringProp>
                    <stringProp name="HTTPSampler.protocol">https</stringProp>
                    <stringProp name="HTTPSampler.contentEncoding"></stringProp>
                    <stringProp name="HTTPSampler.path">/testing/tokens/generate</stringProp>
                    <stringProp name="HTTPSampler.method">POST</stringProp>
                    <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                    <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
                    <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                    <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                    <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                    <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
                    <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                    <stringProp name="HTTPSampler.response_timeout"></stringProp>
                    <stringProp name="TestPlan.comments">Created from cURL on 2019-09-26T14:51:38.3502098</stringProp>
                  </HTTPSamplerProxy>
                  <hashTree>
                    <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP HeaderManager" enabled="true">
                      <collectionProp name="HeaderManager.headers">
                        <elementProp name="Content-Type" elementType="Header">
                          <stringProp name="Header.name">Content-Type</stringProp>
                          <stringProp name="Header.value">application/json</stringProp>
                        </elementProp>
                        <elementProp name="Accept" elementType="Header">
                          <stringProp name="Header.name">Accept</stringProp>
                          <stringProp name="Header.value">application/json</stringProp>
                        </elementProp>
                      </collectionProp>
                      <stringProp name="TestPlan.comments">Created from cURL on 2019-09-26T14:51:38.3522113</stringProp>
                    </HeaderManager>
                    <hashTree/>
                    <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor: Not required as we are adding token from beanshell assertion " enabled="false">
                      <stringProp name="JSONPostProcessor.referenceNames">token</stringProp>
                      <stringProp name="JSONPostProcessor.jsonPathExprs">$.token</stringProp>
                      <stringProp name="JSONPostProcessor.match_numbers">0</stringProp>
                    </JSONPostProcessor>
                    <hashTree/>
                    <BeanShellAssertion guiclass="BeanShellAssertionGui" testclass="BeanShellAssertion" testname="BeanShell Assertion" enabled="true">
                      <stringProp name="BeanShellAssertion.query">import net.minidev.json.JSONArray;
import net.minidev.json.JSONObject;
import net.minidev.json.parser.JSONParser;
import net.minidev.json.parser.ParseException;

Failure=true;
try {

	JSONParser p = new JSONParser();
	JSONObject obj = (JSONObject) p.parse(prev.getResponseDataAsString());
	String sToken  =  obj.get(&quot;token&quot;);
	if (sToken != null) {
		Failure = false;

			props.put(&quot;globaltoken&quot;, sToken);
			props.put(&quot;tokengenerationtime&quot;, System.currentTimeMillis().toString());		
			props.put(&quot;expired&quot;, &quot;false&quot;);		
			//log.info(&quot;sToken:&quot; + sToken);
		
	}
	else {
		FailureMessage = &quot;sToken is null&quot;;
	}
			
}
catch (Exception e) {
	//log.info(&quot;Exception in token generation:&quot; + e);
	FailureMessage = &quot;exception in token generation parsing assertion&quot;;

}
</stringProp>
                      <stringProp name="BeanShellAssertion.filename"></stringProp>
                      <stringProp name="BeanShellAssertion.parameters"></stringProp>
                      <boolProp name="BeanShellAssertion.resetInterpreter">false</boolProp>
                    </BeanShellAssertion>
                    <hashTree/>
                    <ResultAction guiclass="ResultActionGui" testclass="ResultAction" testname="Result Status Action Handler" enabled="true">
                      <intProp name="OnError.action">4</intProp>
                      <stringProp name="TestPlan.comments">// retry token generation in case of failures</stringProp>
                    </ResultAction>
                    <hashTree/>
                  </hashTree>
                </hashTree>
              </hashTree>
            </hashTree>
          </hashTree>
        </hashTree>
      </hashTree>
      <kg.apc.jmeter.threads.UltimateThreadGroup guiclass="kg.apc.jmeter.threads.UltimateThreadGroupGui" testclass="kg.apc.jmeter.threads.UltimateThreadGroup" testname="jp@gc - Ultimate Thread Group" enabled="true">
        <collectionProp name="ultimatethreadgroupdata">
          <collectionProp name="1345460778">
            <stringProp name="49">1</stringProp>
            <stringProp name="48">0</stringProp>
            <stringProp name="48">0</stringProp>
            <stringProp name="1722">60</stringProp>
            <stringProp name="0"></stringProp>
          </collectionProp>
        </collectionProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <intProp name="LoopController.loops">-1</intProp>
        </elementProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
      </kg.apc.jmeter.threads.UltimateThreadGroup>
      <hashTree>
        <kg.apc.jmeter.timers.VariableThroughputTimer guiclass="kg.apc.jmeter.timers.VariableThroughputTimerGui" testclass="kg.apc.jmeter.timers.VariableThroughputTimer" testname="jp@gc - Throughput Shaping Timer" enabled="true">
          <collectionProp name="load_profile">
            <collectionProp name="1925063852">
              <stringProp name="49">1</stringProp>
              <stringProp name="49">1</stringProp>
              <stringProp name="48687">120</stringProp>
            </collectionProp>
          </collectionProp>
        </kg.apc.jmeter.timers.VariableThroughputTimer>
        <hashTree/>
        <OnceOnlyController guiclass="OnceOnlyControllerGui" testclass="OnceOnlyController" testname="Once Only Controller" enabled="false">
          <stringProp name="TestPlan.comments">This register service call should be only first time when service is not registered to obtain the private key. 
change the ${service} with intended service name. 
Save the privatekey getting as response in privatekey in as it is format. </stringProp>
        </OnceOnlyController>
        <hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Register Service " enabled="true">
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">{&#xd;
  &quot;service&quot;: &quot;${service}&quot;&#xd;
}&#xd;
</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain"></stringProp>
            <stringProp name="HTTPSampler.port"></stringProp>
            <stringProp name="HTTPSampler.protocol"></stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">/register</stringProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
            <stringProp name="TestPlan.comments">PCOM Service registartion Key - {&quot;key&quot;:&quot;LS0tLS1
CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JR1RBZ0VBTUJNR0
J5cUdTTTQ5QWdFR0NDcUdTTTQ5QXdFSEJIa3dkd0lCQVFRZ2tOOWI2Z1VGZ2o5bG5Mc2EKM3F5RTRKMkE0V0pzaUt5bVlSK2o3eF
d4SG5PZ0NnWUlLb1pJemowREFRZWhSQU5DQUFTMkMwRDFqT1RVNU9wdQorWHN4QmxGSTdQQWMxN1h0OWxyelFFZEVxc0NiV2RreH
NDV0RPVUMzSXVxSHMzNG9zOE5yQ3gyc0syVWFNN0U4CjlEMHlGNkszCi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K&quot;}</stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP HeaderManager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="accept" elementType="Header">
                  <stringProp name="Header.name">Accept</stringProp>
                  <stringProp name="Header.value">*/*,application/json</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Content-type</stringProp>
                  <stringProp name="Header.value">application/v1+json</stringProp>
                </elementProp>
              </collectionProp>
              <stringProp name="TestPlan.comments">Created from cURL on 2019-06-21T18:39:28.091</stringProp>
            </HeaderManager>
            <hashTree/>
            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Assertion" enabled="true">
              <collectionProp name="Asserion.test_strings">
                <stringProp name="51517">409</stringProp>
                <stringProp name="49586">200</stringProp>
              </collectionProp>
              <stringProp name="TestPlan.comments">If service is already registered then 409 response code is coming. In that case default value for private key will be used. </stringProp>
              <stringProp name="Assertion.custom_message"></stringProp>
              <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
              <boolProp name="Assertion.assume_success">true</boolProp>
              <intProp name="Assertion.test_type">34</intProp>
            </ResponseAssertion>
            <hashTree/>
            <JSONPostProcessor guiclass="JSONPostProcessorGui" testclass="JSONPostProcessor" testname="JSON Extractor" enabled="true">
              <stringProp name="JSONPostProcessor.referenceNames">privateKey</stringProp>
              <stringProp name="JSONPostProcessor.jsonPathExprs">$.key</stringProp>
              <stringProp name="JSONPostProcessor.match_numbers"></stringProp>
              <stringProp name="JSONPostProcessor.defaultValues">LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JR1RBZ0VBTUJNR0J5cUdTTTQ5QWdFR0NDcUdTTTQ5QXdFSEJIa3dkd0lCQVFRZzUxQzg3akpxUGNVMndYc2MKTnFhaitqOW1oUmZVZXVJRnQ3bGFESUFMOHZLZ0NnWUlLb1pJemowREFRZWhSQU5DQUFST2FkclRwaUNhU3pKNgpvN0JLN1NlN1UzRktTc0c5Z041czBBdkRZcGZxOHRyWjROZHNUSlVFQzYyZDVCcFU4WDV0MFppK09iTGxxMzZECmpJc1lhdHpXCi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K</stringProp>
            </JSONPostProcessor>
            <hashTree/>
            <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <boolProp name="resetInterpreter">false</boolProp>
              <stringProp name="script">if(vars.get(&quot;hostname&quot;).contains(&quot;l2&quot;)&amp;&amp;vars.get(&quot;service&quot;).equals(&quot;pcom-metric&quot;)){
	props.put(&quot;privateKey&quot;,&quot;LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JR1RBZ0VBTUJNR0J5cUdTTTQ5QWdFR0NDcUdTTTQ5QXdFSEJIa3dkd0lCQVFRZzUxQzg3akpxUGNVMndYc2MKTnFhaitqOW1oUmZVZXVJRnQ3bGFESUFMOHZLZ0NnWUlLb1pJemowREFRZWhSQU5DQUFST2FkclRwaUNhU3pKNgpvN0JLN1NlN1UzRktTc0c5Z041czBBdkRZcGZxOHRyWjROZHNUSlVFQzYyZDVCcFU4WDV0MFppK09iTGxxMzZECmpJc1lhdHpXCi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K&quot;);
}
else{
	props.put(&quot;privateKey&quot;,vars.get(&quot;privateKey&quot;));
}

</stringProp>
            </BeanShellPostProcessor>
            <hashTree/>
            <JSONPathAssertion guiclass="JSONPathAssertionGui" testclass="JSONPathAssertion" testname="JSON Assertion" enabled="false">
              <stringProp name="JSON_PATH">$.key</stringProp>
              <stringProp name="EXPECTED_VALUE"></stringProp>
              <boolProp name="JSONVALIDATION">false</boolProp>
              <boolProp name="EXPECT_NULL">false</boolProp>
              <boolProp name="INVERT">false</boolProp>
              <boolProp name="ISREGEX">true</boolProp>
            </JSONPathAssertion>
            <hashTree/>
          </hashTree>
        </hashTree>
        <ModuleController guiclass="ModuleControllerGui" testclass="ModuleController" testname="Module Controller" enabled="true">
          <collectionProp name="ModuleController.node_path">
            <stringProp name="764597751">Test Plan</stringProp>
            <stringProp name="764597751">Test Plan</stringProp>
            <stringProp name="1506430348">setUp Thread Group</stringProp>
            <stringProp name="-1837719928">Module GenerateAuthToken</stringProp>
            <stringProp name="1300977279">If Controller</stringProp>
          </collectionProp>
        </ModuleController>
        <hashTree/>
        <ThroughputController guiclass="ThroughputControllerGui" testclass="ThroughputController" testname="Get Public Keys" enabled="true">
          <intProp name="ThroughputController.style">1</intProp>
          <boolProp name="ThroughputController.perThread">false</boolProp>
          <intProp name="ThroughputController.maxThroughput">1</intProp>
          <stringProp name="ThroughputController.percentThroughput">${__P(TC_GetPublicKeys,100)}</stringProp>
        </ThroughputController>
        <hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Get Public Keys" enabled="true">
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
              <collectionProp name="Arguments.arguments"/>
            </elementProp>
            <stringProp name="HTTPSampler.domain">${p_authserver}</stringProp>
            <stringProp name="HTTPSampler.port"></stringProp>
            <stringProp name="HTTPSampler.protocol">https</stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">/keys/${Keyid}</stringProp>
            <stringProp name="HTTPSampler.method">GET</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
            <stringProp name="TestPlan.comments">Created from cURL on 2019-06-21T15:37:02.203</stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP HeaderManager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="accept" elementType="Header">
                  <stringProp name="Header.name">Accept</stringProp>
                  <stringProp name="Header.value">application/json</stringProp>
                </elementProp>
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">Content-Type</stringProp>
                  <stringProp name="Header.value">application/v1+json</stringProp>
                </elementProp>
              </collectionProp>
              <stringProp name="TestPlan.comments">Created from cURL on 2019-06-21T15:37:02.203</stringProp>
            </HeaderManager>
            <hashTree/>
            <BeanShellPreProcessor guiclass="TestBeanGUI" testclass="BeanShellPreProcessor" testname="BeanShell PreProcessor" enabled="true">
              <boolProp name="resetInterpreter">false</boolProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="filename"></stringProp>
              <stringProp name="script">import org.apache.commons.codec.binary.Base64;

try{
String response = vars.get(&quot;token&quot;);
String[] arr=response.split(&quot;\\.&quot;);
String actualvalueheader=arr[0].replaceAll(&quot;-&quot;,&quot;+&quot;);
actualvalueheader=actualvalueheader.replaceAll(&quot;_&quot;,&quot;/&quot;);
byte[] decoded_responseheader = Base64.decodeBase64(actualvalueheader);
String headers=new String(decoded_responseheader);
String LB=&quot;\&quot;kid\&quot;:\&quot;&quot;;
String Kid=headers.substring(headers.indexOf(LB)+LB.length(),headers.indexOf(&quot;,&quot;)-1);
vars.put(&quot;Keyid&quot;,Kid);

}
catch (Exception e) {
	log.error(e);
}</stringProp>
            </BeanShellPreProcessor>
            <hashTree/>
            <JSONPathAssertion guiclass="JSONPathAssertionGui" testclass="JSONPathAssertion" testname="JSON Assertion" enabled="true">
              <stringProp name="JSON_PATH">$.key</stringProp>
              <stringProp name="EXPECTED_VALUE"></stringProp>
              <boolProp name="JSONVALIDATION">false</boolProp>
              <boolProp name="EXPECT_NULL">false</boolProp>
              <boolProp name="INVERT">false</boolProp>
              <boolProp name="ISREGEX">true</boolProp>
            </JSONPathAssertion>
            <hashTree/>
          </hashTree>
        </hashTree>
        <BeanShellPostProcessor guiclass="TestBeanGUI" testclass="BeanShellPostProcessor" testname="BeanShell PostProcessor" enabled="true">
          <boolProp name="resetInterpreter">false</boolProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="script">// props.put(&quot;tokenexpirytime&quot;, &quot;60000&quot;);

// Token expired
try {
	//log.info(&quot;initial expired=&quot; + props.get(&quot;expired&quot;) + &quot;initial expired value&quot; + props.get(&quot;globaltoken&quot;));

	Long expired = System.currentTimeMillis() - Long.parseLong(props.get(&quot;tokengenerationtime&quot;));
	Boolean isexpired = expired &gt; Long.parseLong(props.get(&quot;tokenexpirytime&quot;)) ? true : false;
	props.put(&quot;expired&quot;, isexpired.toString());
	//log.info(&quot;expired=&quot; + props.get(&quot;expired&quot;) + &quot;expired value&quot; + expired.toString());
}
catch (Exception e) {
//	log.info(&quot;Exception in checking expiry:&quot; + e);
	props.put(&quot;expired&quot;, &quot;true&quot;);
}
</stringProp>
          <stringProp name="TestPlan.comments">// Add this at the root level so that everysingle call can re-evaluate and thereby reduce error rates so any other thread in top level can call authtoken
// if you don&apos;t do this, then all threads will re-evalute the auth only at the top and it can create problems and increased error rates</stringProp>
        </BeanShellPostProcessor>
        <hashTree/>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
